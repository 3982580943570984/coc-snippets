snippet dfs "depth-first search" b
void dfs (int s) {
	if (!visited[s]) {
		visited[s] = true;
		for (const auto& u : adj[s])
			dfs(u);
	}
}
endsnippet

snippet bfs "breadth-first search" b
std::queue<std::int64_t> q;
void bfs (int x) {
	visited[x] = true;
	q.push(x);
	while (!q.empty()) {
		int s = q.front(); q.pop();
		for (const auto& u : adj[s]) {
			if (visited[u]) continue;
			visited[u] = true;
			q.push(u);
		}
	}
}
endsnippet

snippet dijkstra "single-source shortest paths" b
const int64_t n = 1e5+5;
void dijkstra (int s) {
	for (int i = 1; i <= n; ++i) dist[i] = inf;
	dist[s] = 0;
	pq.push({0, s});
	while (!pq.empty()) {
		int a = pq.top().second; pq.pop();
		if (!vis[a]) {
			vis[a] = true;
			for (const auto& u : adj[a]) {
				int b = u.first;
				int w = u.second;
				if (dist[a] + w < dist[b]) {
					dist[b] = dist[a] + w;
					pq.push({-dist[b], b});
				}
			}
		}
	}
}
endsnippet

snippet dijkstra_restore "single-source shortest paths with path restoration" b
const int64_t n = 1e5+5;
std::vector<std::int64_t> path(n);
void dijkstra (int s) {
	for (int i = 1; i <= n; ++i) dist[i] = inf;
	dist[s] = 0;
	pq.push({0, s});
	while (!pq.empty()) {
		int a = pq.top().second; pq.pop();
		if (!vis[a]) {
			vis[a] = true;
			for (const auto& u : adj[a]) {
				int b = u.first;
				int w = u.second;
				if (dist[a] + w < dist[b]) {
					dist[b] = dist[a] + w;
					path[b] = a;
					pq.push({-dist[b], b});
				}
			}
		}
	}
}

void restore_path (int start, int end) {
	vector<int> restore;
	for (int v = end; v != start; v = path[v])
		restore.push_back(v);
}
endsnippet
